[개요]
	<정적 컨텐츠>
	웹을 개발한다는 것은 사실 크게 세가지 방법이 있다.

		1.정적 컨텐츠
		2.MVC와 템플릿 엔진
		3.API

	1.정적 컨텐츠
		정적 컨텐츠가 뭐냐면 이전에 스프링에서 웰컴 페이지 했던 것처럼 서버에서 처리하는 로직          없이 그대로 웹브라우저에 그대로 보내주는 거다 이게 정적 컨텐츠다
		

	2.MVC와 템플릿 엔진
		가장 많이 사용하는 방식이다. 예를들어 JSP, PHP 같은 템플릿 엔진이다.
		 html을 그냥 주는 게 아니라 서버에서 프로그래밍해서 html을 동적으로 바꿔서
		 웹으로 보내는거다.
		이런걸 템플릿 엔진이라고 하고 그걸 하기 위해서 컨트롤러,
		 모델, 템플릿 엔진  화면 이 세가지를 모델뷰 컽르롤러, MVC 라고 한다. 


	3.API
		API는 만약 안드로이나 아이폰 클라이언트랑 개발을 해야한다면 json 이라는 데이터 
		 포멧으로 내려준다. html 이런걸 내리는 게 아니라 json 이라는 
		 어떤 데이터 구조 포멧으로 클라이언트 한테 데이터를 전달하는 게 요즘 API
		 방식이다.
		 
		 

[정적 컨텐츠]
		스프링 부트는 정적 컨텐츠 기능을 자동으로 제공한다. 스프링 기본 설정으로
		 스프링 부트는 정적 컨텐트를 /static 이 폴더에서 찾아서 제동한다고 되어있다.

	<실습>
		인텔리제이 에서 resources/static 에 hello-static.html이라고 만든다. 
		 아무 html을 작성해 보겠다.

		 [resources/static/hello-static.html]
		 <!DOCTYPE html>  
		<html lang="en">  
		<head>  
		    <meta charset="UTF-8">  
		    <title>Title</title>  
		</head>  
		<body>  
		    <h2>          
		           정적 컨텐츠이다.  
		    </h2>  
		</body>  
		</html>
		
		이제 서버를 실행시켜 보자.
		 서버를 실행시키고 ulr로 바로 접근이 가능하다 
		 http://localhost:8080/hello-static.html

	   ![[hello-static 실행화면 1.png]]
		정적파일을 resources/static 에 넣으면 그대로 반환이 된다.
		대신 여기에는 어떤 프로그밍을 할수는 없다, html 파일 그대로 반환이 된다.
		이걸 그림으로 설명해 보겠다. 

	![[스프링 정적 컨텐츠 원리.png]]

	간단하게 원리를 설명해 보자면
	웹 브라우저에서 localhost:8080/hello-static.html을 스프링 부트에 내장되어 있는
	톰캣 서버가 받는데 톰캣은 그걸 다시 스프링 컨테이너로 넘긴다.
	근데 스프링은 요청이 오게되면 컨트롤러 쪽에서 hell-static이 있는지 먼저 찾아본다. 
	컨트롤러가 우선순위를 먼저 가진다는 소리다.

	현재 컨트롤러에는 hello라는 컨트롤러는 있지만 hello-static이라는
	매핑이된 컨트롤러는 없다.

	그러면 스프링 부트는 어떻게 하냐면 여기 내부에 있는 resources/static 에서
	hello-statc.html을 찾는다. 찾고 바로 웹으로 반환한다.
	
[MVC와 템플릿 엔진]
	MVC란 Model-View-Controller 이다. 과거에는 컨트롤러랑 뷰 라는게 따로 분리되어 있지
	않았다. 뷰에 모든 작업을 전부 처리했었다. JSP로 예전엔 이런식으로 개발을 많이 헀다.
	그걸 모델1 방식이라고 한다. 지금은 MVC스타일로 많이 한다 왜냐면 뷰는 화면을 그리는데에
	모든 역량을 집중해야 한다.

	그리고 컨트롤러나 모델에 관련된 부분들은 비즈니스 로직과 관련이 있거나 내부적인걸 처리하는
	데에 집중을 해야한다. 그래서 Model-View-Controller 로 쪼갠거다.
	이번엔 존더 내용이 있는 컨트롤러를 만들어 보겠다.
	
	<실습>
		저번에 실습한 controller/HelloController 에 하나의 함수를 더 만들어 줄거다.
		
		[controller/HelloController]
		@GetMapping("hello-mvc")  
		public String hellomvc(@RequestParam("name") String name, Model model){  
		    model.addAttribute("name",name);  
		    return "hello-template";  
		} 
		이번엔 파라미터를 받을거다 hellomvc의 매개값인 String name, 에 어노테이션으로
		RequestParam("name") 으로 해준다 이러면 외부 웹에서 쿼리스트링으로 직접 값을
		받을수 있다. 그리고 model.addAttribute("name",name);로 외부에서 넘어온 값을
		담아 줄거다.

		그리고 마지막으로  retuen 으로 hello-templete로 으로 넘겨줄거다. 


		[resources/templates/hello-templete.html]
		<!DOCTYPE html>  
		<html lang="en" xmlns:th="http://www.thymeleaf.org">  
		<head>  
		    <meta charset="UTF-8">  
		    <title>Title</title>  
		</head>  
		<body>  
		    <p th:text="'hello' + ${name}">hello! empty</p>
		</body>  
		</html>

		내용은 이전 처음에 실습했을때와 같다. 

		타임리프의 장점 resources/templates/hello-templete.html 이파일을 우클릭해보면 
		Absolute Path라도 있다. 이걸 웹 URL에 붙이면 서버를 거치지 않고 그대로 html파일을 
		열어볼수 있다. hello! empty 이 값은 없어도 된다. 

		<p th:text="'hello' + ${name}">hello! empty>  여기서 "'hello' + ${name}" 이
		내용으로 hello! empty 이 내용이 바뀐다. 컨트롤러의 
		model.addAttribute("name",name);  name 키가 ${name} 이거다.

		
		![[Pasted image 20240810182510.png]]
	
	

	1. **웹 브라우저**: 사용자가 웹 브라우저에서 `localhost:8080/hello-mvc`라는
	    URL을 요청 한다.
	2. **내장 톰캣 서버**: 이 요청이 내장 톰캣 서버에 도달한다.
	3. **스프링 컨테이너의 Controller 처리**:
	    - 요청이 스프링 컨테이너로 전달되면, `helloController`라는 이름의 컨트롤러에서 해당         요청을 처리한다.
	    - 이 컨트롤러는 "hello-template"이라는 이름의 뷰(View)를 반환(return)하고,                "name"이라는 키로 "spring"이라는 값을 가진 모델 데이터를 함께 전달한다.
	4. **뷰 리졸버(ViewResolver)**:
	    - 스프링의 뷰 리졸버는 반환된 뷰 이름("hello-template")을 바탕으로 실제 렌더링할            HTML 템플릿 파일(`templates/hello-template.html`)을 찾는다.
	    - 여기서 Thymeleaf와 같은 템플릿 엔진이 해당 HTML 파일을 처리해, 모델 데이터를              HTML에 반영하여 최종적으로 완성된 HTML 문서를 생성한다.
	5. **HTML 반환**: 최종적으로 생성된 HTML 문서는 웹 브라우저로 반환되어,                        사용자에게 표시된다.
	
	### 요약
	
	이 이미지는 Spring Boot에서 MVC 패턴을 사용해 클라이언트의 요청을 처리하고, 템플릿 엔진      (예: Thymeleaf)을 사용해 동적인 HTML 페이지를 생성하여 응답하는 과정을 설명하고 있다.        컨트롤러는 클라이언트의 요청을 처리하고, 필요한 데이터를 모델로 전달하며, 템플릿 엔진은 이      데이터를 바탕으로 최종 HTML 페이지를 렌더링한다.

[API]
	이번엔 스프링 웹 개발에서 이야기하는 API방식에 대해서 알아보겠다.

	정적 컨텐츠를 제외하면 MVC 방싱처럼 뷰를 찾아서 템플릿 엔진을 통해서 화면을
	렌더링해서 HTML을 웹브라우저에 넘겨주는 방법이 있고 그 다음에 API를 쓰는 방식이 있다.

	 정적 컨텐츠를 제외하면 두가지만 기억하면된다. 화면을 HTML로 내리냐 아니면 API방식으로
	 데이터를 바로 내리냐 를 알고 있으면 된다.

	<실습>
	@GetMapping(hello-api)  
    @ResponseBody    
    public String helloString(@RequestParam("name") String name){  
        return "hello" + name;  
    }  

	이번에는 @ResponseBody 라는 것이 추가되었다. ResponseBody 어노테이션의 의미는
	HTML에 나오는 body태그를 이야기 하는 것이 아니라 http 에서 헤더부와 바디부가 있는건
	알고 있을 것이다. HTTP 통신 프로토콜이 그렇게 되어있다. Body 부에 "hello" + name;  
	 이 데이터를 내가 직접 넣어 주겠다는 뜻이다. 

	만약 쿼리스트링에 name 키값에 kim이라고 넣어주면  이전의 MVC와 템플릿 엔진 과의
	차이가 뭐냐면 view가 없다. 그냥 이문자가 그대로 내려간다.

	실제 웹에서 개발자 도구를 열어보게되면 HTML 태그 같은건 하나도 없다. 그냥 문자만 그대로
	내려 갔다.

	이전에 템플릿 엔진은 화면을 가지고 템플릿 뷰라는 템플릿이 있는 상황에서 데이터를 조작하는
	방식이고 지금은 return 값에 있는 "hello" + name 이 데이터를 그대로 내려준다. 사실 지금
	한건 실습으로 보여준것 뿐이고 실제로는 이런식으로 무식하게 사용할 일은 없다.

	 지금부터가 진짜다. 만약에 문자가 아니라 데이터라고 한다면? 이것 때문에 API 방식을 많이
	 쓴다고 한다.
	실제로 해보겠다.

	<실습>
	@GetMapping("hello-api2")  
	@ResponseBody  
	public Hello helloApi(@RequestParam("name") String name) {  
	Hello hello = new Hello();  
	hello.setName(name);  
	return hello;  
	}  
	
	
	static class Hello{  // 중첩 정적 클래스
	private String name;  
	
	public String getName(){  
	return name;  
	}  
	
	public void setName(String name){  
	this.name = name;  
	
	}  
	}

	이번에 넘길 데이터는 전과 같이 문자열이 아니라 객체를 넘길거다. 그러기 위해 중첩 클래스로
	hello를 만들어 주고 hello 객체를 만들어 리턴해 줬다. 이제 이코드를 실행 시켜 보면


	![[Pasted image 20240816171041.png]]

	{"name":"spring"} 이렇게 나오는데 이건 JSON 이라는 방식이다. 제이슨은 key와 value로
	이루어진 구조이다. name 이 key고 spring이 vlaue 다. 여기서 궁금한 점이 있을
	거다 자바 문법을 제대로 공부한 사람이라면 return hello;  라고 했는데 왜 객체의
	참조 값이 아닌 뜬금 없이 key와 value가 나오는지 궁금할 것이다. 보통의 자바에서는

	 return hello; 만할경우 그 객체의 참조값 을 넘겨준다 하지만 스프링 부트는 조금 다르다
	 @ReponseBody 어노테이션은 메소드가 반환하는 객체를 JSON형태로 변환해서 HTTP 응답
	 본문에(body)에 담아 변환하도록 만들어 준다. 스프링 부트는 내부적으로 Jackson이라는 
	 라이브러리를 용해서 객체를 json으로 변환해서 이과정이 자동으로 이루어지기 때문에
	 객체만 반환해도 이 과정이 자동으로 이루어진다고 생각하면 된다. 

	과거엔 XML 방시도 많이 쓰였다 HTML 도 XML 방식이다 하지만 XML 방식은 무겁다

	그래서 최근에는 JSON으로 기본으로 반환한다. 이제 다시 어떻게 동작을 하는지 그림을
	보면서 설명해 보겠다.

	![[Pasted image 20240816173841.png]]

	ResponseBody 사용원리에 대해 설명해 보겠다. 웹브라우저에서 http로 hello-api라고 요청이 
	들어오면 톰캣 내장 서버가 스프링 컨테이너의 컨트롤러에 넘겨준다. 그럼 스프링 컨테이너는 
	helloController에서 hello-api찾아서 확인을 하는데 @ResponseBody 어노테이션이 있는것을
	확인한다. 이전에는 그냥 뷰 리졸버한테 보냈지만 @ResponseBody가 있을 경우에는 다르다. 

	@ResponseBody가 있을 경우에는 HTTP응답에 그대로 넣는다. 그런데 hello-api는 문자가 아니
	객체이다. 기존에 문자값의 경우에는 그냥 HTTP 응답에 바로 넣어서 웹으로 보냈다.

	객체일 경우에는 기본값이 JSON방식의 데이터로 만들어서 HTTP응답에 반환하는게 기본 정책이
	다. 

	어쨋든 @ResponseBody가 있으면 HTTPMessageConverter가 동작을 한다 만약 
	HTTPMessageConverter로 넘어온게 단순한 문자면 StringConverter가 동작을 하고
	객체면 JsonConerter가 동작을 한다. 그래서 객체를 JSON 스타일로 바꾼다.

	<정리> 
	1.@ResponseBody 가 사용되면 HTTP바디에 문자 내용을 직접 반환을 한다.
	2.viewResolver 대신 HttpMessageConverter가 동작을 한다.
	3.기본 문자처리 : StringHttpMessageConverter
	4.기본 객체처리 : MappingJackson2HttpMessageConverter
	
	
	


[[회원 관리 예제 - 백엔드 개발]]]
